---
title: "Data Center Apprenticeship:\nAdvanced treatment of data types and functions in R"
subtitle: "Spring 2024" 
date: "Last updated: `r Sys.Date()`"
output:
  md_document:
    variant: gfm
    preserve_yaml: true
    toc: true
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE, message = FALSE, warning = FALSE, error = FALSE)
```

```{r}
library(tidyverse)
library(lubridate) # for dates
```

# More on data types

Source: Hadley Wickham: [Advanced R](https://adv-r.hadley.nz/vectors-chap.html) (Chapter 3: Vectors).

## Vectors

### Scalars: testing and coercion

```{r}
# Create a tibble with logical column, coerce it to other types
vectors <- tibble(
 logical = c(TRUE, FALSE, NA),
 integer = as.integer(logical),
 numeric = as.numeric(logical),
 character_log = as.character(logical),
 character_num = as.character(numeric)
)

print(vectors)

# Logical is coerced to numeric
class(c(vectors$logical, vectors$numeric))

# Logical and numeric are coerced to character
class(c(vectors$logical, vectors$numeric, vectors$character_log, vectors$character_num))

# Logical is not numeric or character, just coercible to them
is.numeric(vectors$logical)
is.character(vectors$logical)
```
### Factors: coercion, levels, ordering

```{r}
# Logical and factor is numbered differently when coerced to numeric
factors <- tibble(
 logical = c(TRUE, FALSE, NA),
 factor = as.factor(logical),
 numeric_log = as.numeric(logical),
 numeric_fac = as.numeric(factor)
)

print(factors)

# Define a character vector
char <- c("x", "x", "x")

# Convert character vector to factor with levels x and y
factor <- factor(char, levels = c("x", "y"))

# Only factor can be coerced to numeric, not character
as.numeric(char)
as.numeric(factor)

# Table counts all factor levels, even with no observations
table(char)
table(factor)

# Order character vector with levels x < y
ordered(char, levels = c("x", "y"))

```

### Dates: `lubridate`

```{r}
# Create a vector of dates
dates <- c(ymd(20201001), dmy("31082022"), Sys.Date(), today())
dates

# Convert dates to datetime
as_datetime(dates)

# Convert dates to numeric
as.numeric(dates)

# Reconstruct dates from numeric representation as number of days since base date (01/01/1970)
ymd(19700101) + days(as.numeric(dates))

# Get current date and time
now()

# Convert decimal years to date
date_decimal(c(1990, 1990.1, 1990.5))

# Extract year, quarter, and week from dates
year(dates)
quarter(dates)
week(dates)

# Difference between time and difftime
dates + months(1)
dates + dmonths(1)

# Round down dates to nearest day 
floor_date(dates + dmonths(1), unit = "day")

```

### Vector attributes

```{r}
# Create a named vector
v <- c("a" = 1, "b" = 2, "c" = 3)

# Add an attribute 'other_attribute' to 'v'
attr(v, "other_attribute") <- "x"

# Display attributes of 'v'
attributes(v)

# Change names of 'v'
names(v) <- c("a1", "b1", "c1")
v <- setNames(v, c("a2", "b2", "c2"))

# Convert 'v' to a dataframe and add row names as a column
# Note: as_tibble() loses rownames
as.data.frame(v) |> rownames_to_column()

# Get dimensions of 'v'
# vectors always have NULL dimension
dim(v)

# Get dimensions of 'v' as a matrix 
# matrices have two dimensions (rows x columns)
dim(as.matrix(v))

```

### NA, NULL, NaN

```{r}
# NA: missing
# NaN: not a number
# NULL: special object of length 0
na <- c(NA, NA_integer_, NA_real_, NaN, NULL)

# NULL does not contribute to vector length/content
length(na)
# NA, NaN are all NA, but only NaN is NaN
is.na(na)
is.nan(na)
# object is NULL if it only contains NULL
is.null(na)

# NA and NaN create an observation
tibble(x = NA)
tibble(x = NaN)
# NULL creates tibble with 0 rows, 0 columns
tibble(x = NULL)
```

## Lists

```{r}
# Define list with elements of different types, lengths
l <- list(
  1:3, 
  "a", 
  c(TRUE, FALSE), 
  x = tibble(y = c(2.3, 5.9), z = c(5, 6)),
  l1 = list(l2 = list(1, 2, 3), l3 = list(4, 5))
)

# Access elements of 'l' using different methods
l[1]
l[[1]]
l$x
l$x$y
l["l1"]
l[["l1"]]
l$l1
l$l1$l2
l$l1[["l2"]]
l$l1[[1]]

# convert list to a single vector (character, due to coercion)
unlist(l)
```

## Data frames and tibbles

```{r}
# Create a data frame and a tibble with the same contents
df <- data.frame(x = 1:3, y = letters[1:3])
tbl <- tibble(x = 1:3, y = letters[1:3])

# Compare attributes of 'df' and 'tbl'
attributes(df)
attributes(tbl)

# Get number of rows and columns of 'df'
nrow(df)
ncol(df)

# Get dimensions of 'df'
dim(df)

# Get names of 'df'
names(df)

# Create a complex tibble 
d <- tibble("1 problematic variable name" = 1:3, 
            y = letters[1:3], 
            z = list(c(1:3), c(4:6), c(7:9)),
            tib = list(tibble(x1 = 1:2, y1 = letters[1:2]),
                       tibble(x1 = 3:4, y1 = letters[3:4]),
                       tibble(x1 = 5:6, y1 = letters[5:6])))

# Select a variable; result: tibble
select(d, y)
d[ , "y"]
d[ , 2]

# Pull a variable; result: vector
pull(d, y)
d$y
d[["y"]]
d[[2]]

# Use backquotes for problematic names
select(d, `1 problematic variable name`)
d[ , "1 problematic variable name"]
d[ , 1]

pull(d, `1 problematic variable name`)
d$`1 problematic variable name`
d[["1 problematic variable name"]]
d[[1]]

# Select all variables containing a single lowercase letter
select(d, matches("^[a-z]$"))
# Select which rows and columns to keep
d[2:3, c(1, 3)]

# Unnest 'z' and 'tib' from 'd'
d |> unnest(z)
d |> unnest(tib)
# Default unnest behavior: unnest all list columns (but length mismatch error)
# d |> unnest()
```

# Writing your own functions

Source: Hadley Wickham and Garrett Grolemund: [R for Data Science](https://r4ds.had.co.nz/functions.html) (Chapter 19: Functions); 
Hadley Wickham, Mine Ã‡etinkaya-Rundel, and Garrett Grolemund: [R for Data Science (2e)](https://r4ds.hadley.nz/functions) (Chapter 25: Functions)

## What does a function look like?

```{r}
# Access function definition
sd

# Defining a simple function: rescale a vector so that all elements are between 0 and 1
rescale01 <- function(x) {
  (x - min(x)) / (max(x) - min(x))
}

# Use function defined in global environment
rescale01(x = c(1, 4, 5, 8, 10))

# For short functions, use one line and omit the braces
rescale01 <- function(x) (x - min(x)) / (max(x) - min(x))
```

## Function name, arguments, body, return value(s)

```{r}

```

## Tidy functions: pipes, data masking, tidy evaluation

```{r}

```

## Conditional execution

```{r}

```

## What objects exist in which environment?

```{r}

```


<!-- * view source code of existing functions in console -->
<!-- * why define your own function -->
<!-- * single line or curly braces -->
<!-- * function syntax: function name, returned values, arguments -->

<!--   + good naming conventions -->
<!--   + returned values: one or more objects (list return) -->
<!--   + arguments: names (avoiding `name == name` in function body), default values -->
<!--   + tidy, pipeable functions -->

<!-- * what objects can you use inside and outside the function? -->
<!-- * conditional execution, adding error messages -->

# Iteration with functionals

Hadley Wickham: [Advanced R](https://adv-r.hadley.nz/functionals.html#map) (Chapter 9: Functionals).

## Why should you use functionals?

```{r}

```

## `map()` and its versions

```{r}

```

## Functionals in tidy data wrangling

```{r}

```

## Applying methods to multiple variables with `across()`

```{r}

```

<!-- * functionals instead of loops - why? -->
<!-- * map and its versions (map2, map_df, map_dbl, pmap, ect.) -->
<!-- * function specification: function name or syntax with `~` and `.x`/`.y`(/position/name with `pmap`) -->

<!-- * map in mutate - when is it needed? -->
<!-- * changing multiple variables at once with across  -->