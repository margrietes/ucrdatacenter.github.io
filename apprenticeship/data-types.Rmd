---
title: "Data Center Apprenticeship:\nAdvanced treatment of data types and functions in R"
subtitle: "Spring 2024" 
date: "Last updated: `r Sys.Date()`"
output:
  md_document:
    variant: gfm
    preserve_yaml: true
    toc: true
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE, message = FALSE, warning = FALSE, error = FALSE)
```

```{r}
library(tidyverse)
library(lubridate) # for dates
```

# More on data types

Source: Hadley Wickham: [Advanced R](https://adv-r.hadley.nz/vectors-chap.html) (Chapter 3: Vectors).

## Vectors

### Scalars: testing and coercion

```{r}
vectors <- tibble(
  logical = c(TRUE, FALSE, NA),
  integer = as.integer(logical),
  numeric = as.numeric(logical),
  character_log = as.character(logical),
  character_num = as.character(numeric)
)

print(vectors)

class(c(vectors$logical, vectors$numeric))
class(c(vectors$logical, vectors$numeric, vectors$character_log, vectors$character_num))

is.numeric(vectors$logical)
is.character(vectors$logical)
```
### Factors: coercion, levels, ordering

```{r}
factors <- tibble(
  logical = c(TRUE, FALSE, NA),
  factor = as.factor(logical),
  numeric_log = as.numeric(logical),
  numeric_fac = as.numeric(factor)
)

print(factors)

char <- c("x", "x", "x")
factor <- factor(char, levels = c("x", "y"))

as.numeric(char)
as.numeric(factor)

table(char)
table(factor)

ordered(char, levels = c("x", "y"))
```

### Dates: `lubridate`

```{r}
dates <- c(ymd(20201001), dmy("31082022"), Sys.Date(), today())
dates
as_datetime(dates)
as.numeric(dates)
ymd(19700101) + days(as.numeric(dates))

now()
date_decimal(c(1990, 1990.1, 1990.5))

year(dates)
quarter(dates)
week(dates)

dates + months(1)
dates + dmonths(1)
floor_date(dates + dmonths(1), unit = "day")
```

### Vector attributes

```{r}
v <- c("a" = 1, "b" = 2, "c" = 3)
attr(v, "other_attribute") <- "x"
attributes(v)

names(v) <- c("a1", "b1", "c1")
v <- setNames(v, c("a2", "b2", "c2"))

as.data.frame(v) |> 
  rownames_to_column()

dim(v)
dim(as.matrix(v))
```

### NA, NULL, NaN

```{r}
na <- c(NA, NA_integer_, NA_real_, NaN, NULL)
length(na)
is.na(na)
is.nan(na)
is.null(na)

tibble(x = NA)
tibble(x = NaN)
tibble(x = NULL)
```

## Lists

```{r}
l <- list(
  1:3, 
  "a", 
  c(TRUE, FALSE), 
  x = tibble(y = c(2.3, 5.9), z = c(5, 6)),
  l1 = list(l2 = list(1, 2, 3), l3 = list(4, 5))
)

l[1]
l[[1]]
l$x
l$x$y
l["l1"]
l[["l1"]]
l$l1
l$l1$l2
l$l1[["l2"]]
l$l1[[1]]

unlist(l)
```

## Data frames and tibbles

```{r}
df <- data.frame(x = 1:3, y = letters[1:3])
attributes(df)

tbl <- tibble(x = 1:3, y = letters[1:3])
attributes(tbl)

nrow(df)
ncol(df)
dim(df)
names(df)

d <- tibble("1 problematic variable name" = 1:3, 
            y = letters[1:3], 
            z = list(c(1:3), c(4:6), c(7:9)),
            tib = list(tibble(x1 = 1:2, y1 = letters[1:2]),
                       tibble(x1 = 3:4, y1 = letters[3:4]),
                       tibble(x1 = 5:6, y1 = letters[5:6])))

select(d, y)
d[ , "y"]
d[ , 2]

pull(d, y)
d$y
d[["y"]]
d[[2]]

select(d, `1 problematic variable name`)
d[ , "1 problematic variable name"]
d[ , 1]

pull(d, `1 problematic variable name`)
d$`1 problematic variable name`
d[["1 problematic variable name"]]
d[[1]]

select(d, matches("^[a-z]$"))
d[2:3, c(1, 3)]

d |> unnest(z)
d |> unnest(tib)
# d |> unnest()
```

# Writing your own functions

Source: Hadley Wickham and Garrett Grolemund: [R for Data Science](https://r4ds.had.co.nz/functions.html) (Chapter 19: Functions); 
Hadley Wickham, Mine Ã‡etinkaya-Rundel, and Garrett Grolemund: [R for Data Science (2e)](https://r4ds.hadley.nz/functions) (Chapter 25: Functions)

## What does a function look like?

```{r}

```

## Function name, arguments, body, return value(s)


## Tidy functions: pipes, data masking, tidy evaluation


## Conditional execution


## What objects exist in which environment?


<!-- * view source code of existing functions in console -->
<!-- * why define your own function -->
<!-- * single line or curly braces -->
<!-- * function syntax: function name, returned values, arguments -->

<!--   + good naming conventions -->
<!--   + returned values: one or more objects (list return) -->
<!--   + arguments: names (avoiding `name == name` in function body), default values -->
<!--   + tidy, pipeable functions -->

<!-- * what objects can you use inside and outside the function? -->
<!-- * conditional execution, adding error messages -->

# Iteration with functionals

Hadley Wickham: [Advanced R](https://adv-r.hadley.nz/functionals.html#map) (Chapter 9: Functionals).

## Why should you use functionals?

## `map()` and its versions

## Functionals in tidy data wrangling

## Applying methods to multiple variables with `across()`

<!-- * functionals instead of loops - why? -->
<!-- * map and its versions (map2, map_df, map_dbl, pmap, ect.) -->
<!-- * function specification: function name or syntax with `~` and `.x`/`.y`(/position/name with `pmap`) -->

<!-- * map in mutate - when is it needed? -->
<!-- * changing multiple variables at once with across  -->